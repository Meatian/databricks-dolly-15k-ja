{"index":"9093","instruction":"バイナリサーチと他の検索方式はどう違うのですか？","input":"バイナリサーチによるソート配列は、挿入や削除の操作と検索が混在する場合、非常に非効率なソリューションとなります。\n\nこのような操作のたびにO(n)の時間がかかる。さらに、ソートされた配列は、特に要素が頻繁に配列に挿入される場合、メモリの使用を複雑にする可能性があります。より効率的な挿入と削除をサポートするデータ構造は他にもある。バイナリサーチは、完全一致やセットメンバーシップ（対象値が値の集合に含まれるかどうかを判断すること）を実行するために使用できます。より高速な完全一致とセット・メンバーシップをサポートするデータ構造もあります。しかし、他の多くの検索スキームとは異なり、バイナリサーチは効率的な近似マッチングに使用することができ、通常、そのようなマッチングを行うには\n値そのものの種類や構造に関係なく、O(log n)時間の計算が可能です。また、最小・最大の要素を求めるなど、ソートされた配列に対して効率的に実行できる演算もある。\n\nリニアサーチです：\n\n線形探索は、目的の値を見つけるまですべてのレコードをチェックするシンプルな探索アルゴリズムです。線形探索はリンクリストに対して行うことができ、配列よりも高速に挿入と削除が可能です。バイナリサーチは、配列が短い場合を除き、ソートされた配列に対して線形探索より高速ですが、配列はあらかじめソートされている必要があります。クイックソートやマージソートなど、要素の比較に基づくすべてのソートアルゴリズムでは、最低でも\n最悪の場合、O(nlog n)個の比較を行う。線形探索と異なり、バイナリサーチは効率的な近似マッチングに使用することができる。最小・最大の要素を見つけるような操作は、ソートされた配列では効率的に行えるが、ソートされていない配列では行えないものがある。\n\n樹木です：\n\nバイナリーサーチツリーは、バイナリーサーチに似たアルゴリズムで検索します。\nバイナリーサーチツリーとは、バイナリーサーチの原理に基づいて動作するバイナリーツリーデータ構造です。ツリーのレコードはソートされており、ツリーの各レコードはバイナリサーチと同様のアルゴリズムで検索でき、平均対数時間を要する。挿入と削除もバイナリーサーチツリーでは平均して対数時間を必要とします。これは、ソートされた配列の線形時間の挿入と削除よりも高速で、バイナリツリーは、範囲と近似クエリを含む、ソートされた配列で可能なすべての操作を実行する能力を保持することができます。\n\nしかし、バイナリサーチツリーはほとんどの場合、不完全なバランスになるため、バイナリサーチよりも若干性能が悪くなるため、通常はバイナリサーチの方が検索効率が良い。これは、バランス型バイナリサーチ・ツリー（自分のノードのバランスをとるバイナリサーチ・ツリー）にも当てはまることで、可能な限り少ないレベルのツリーを生成することはほとんどないからです。バランスのとれたバイナリサーチ木を除いて、2つの子を持つ内部ノードがほとんどない、ひどくバランスの悪い木になる可能性があり、その結果、平均および最悪の場合の探索時間は、以下のように近づきます。\nn 比較。[e] バイナリサーチツリーは、ソートされた配列よりも多くのスペースを必要とする。\n\nバイナリサーチ・ツリーは、ファイルシステムで効率的に構造化できるため、ハードディスクに格納された外部メモリでの高速検索に適している。B-treeは、この木構造の方法を一般化したものである。B-treeは、データベースやファイルシステムなどの長期記憶装置の構成によく使われる。\n\nハッシュ化する：\nほとんどのハッシュテーブルの実装では、平均して償却された定数時間しか必要としません。しかし、ハッシュは、次小型、次大型、最寄りのキーを計算するような近似マッチには有用ではありません。なぜなら、検索に失敗したときに得られる唯一の情報は、ターゲットがどのレコードにも存在しないことです。バイナリサーチはこのようなマッチングに最適で、対数時間で実行されます。バイナリサーチは近似的なマッチングもサポートします。最小の要素と最大の要素を見つけるようないくつかの操作は、ソートされた配列では効率的に行うことができるが、ハッシュテーブルではできない。\n\nセット・メンバーシップのアルゴリズム\n探索に関連する問題として、セット・メンバーシップがある。バイナリサーチのようなルックアップを行うアルゴリズムであれば、セットメンバーシップにも使用できる。セット・メンバーシップに特化したアルゴリズムもある。ビット配列は最もシンプルで、キーの範囲が限られている場合に便利です。ビットの集合をコンパクトに格納し、各ビットはキーの範囲内の1つのキーを表します。ビット配列は非常に高速で、必要なのは\nJudy配列のJudy1タイプは、64ビットキーを効率的に処理します。\n\n近似的な結果を得るために、ハッシュに基づく別の確率的データ構造であるブルームフィルターは、ビット配列と複数のハッシュ関数を用いてキーを符号化することにより、キーのセットを保存します。ブルームフィルタは、ほとんどの場合、ビット配列よりもスペース効率がよく、速度もそれほど遅くありません。\nk個のハッシュ関数があれば、メンバシップクエリに必要なのは\n O(k)時間です。しかし、ブルームフィルタは誤検出の問題がある。\n\nその他のデータ構造\n他のデータ構造：検索とソートされた配列で利用可能な他の操作の両方について、場合によってはバイナリサーチを改善する可能性のあるデータ構造が存在する。例えば、検索、近似一致、およびソートされた配列で利用可能な操作は、van Emde Boas木、融合木、トライ、およびビット配列などの特殊なデータ構造上でバイナリ検索よりも効率的に実行することができます。これらの特殊なデータ構造は、通常、ある属性を持つキー（通常は小さな整数であるキー）の特性を利用するため、高速になるだけで、その属性を持たないキーでは時間や空間を消費することになる。キーが順序付けられる限り、これらの操作はキーに関係なく、ソートされた配列に対して常に少なくとも効率的に行うことができる。ジュディ配列のようないくつかの構造では、効率と近似マッチングを行う能力を維持しながら、これを軽減するためのアプローチを組み合わせて使用しています。","output":"バイナリサーチを用いたソート配列は、挿入や削除の操作と検索が交錯する場合、非常に非効率的なソリューションとなります。さらに、ソートされた配列は、特に要素が頻繁に配列に挿入される場合、メモリ使用を複雑にする可能性がある。\nバイナリサーチは、配列が短い場合を除き、ソートされた配列に対して線形サーチよりも高速ですが、配列はあらかじめソートされている必要があります。\nバイナリサーチは、バイナリサーチツリーのバランスが不完全である可能性が高いため、通常、バイナリサーチの方が検索効率が高く、結果としてバイナリサーチよりも若干性能が悪くなります。\nハッシュ関数を用いてキーとレコードを対応させるデータ構造である「ハッシュ関数」は、一般にレコードのソートされた配列に対してバイナリサーチよりも高速である。","category":"summarization"}
