{"index":"7779","instruction":"kubernetesに関するこのパラグラフを考えると、Kubernetesのコントロールプレーンのストレージ層とは何でしょうか？","input":"Kubernetesマスターノードは、クラスタのKubernetesコントロールプレーンを処理し、そのワークロードを管理し、システム全体の通信を指示します。Kubernetesコントロールプレーンは、それぞれが独自のプロセスであるさまざまなコンポーネントで構成され、単一のマスターノード上でも、高可用性クラスタをサポートする複数のマスター上でも実行できます[36]。Kubernetesコントロールプレーンの各種コンポーネントは次のとおりです：\n\netcd[37]は、CoreOSが開発した永続的で軽量な分散型のキーバリューデータストアです。etcdは、ネットワークのパーティションが発生した場合、可用性よりも一貫性を優先します（CAP定理を参照）。一貫性は、サービスを正しくスケジューリングして運用するために重要です。\nAPIサーバは、HTTP上のJSONを使用してKubernetes APIを提供し、Kubernetesの内部および外部インターフェースの両方を提供します[35][38] APIサーバは、RESTリクエストを処理および検証してetcd内のAPIオブジェクトの状態を更新し、それによってクライアントがワーカーノードに渡ってワークロードとコンテナを構成できるようにします[39] APIサーバはetcdのウォッチAPIを使用してクラスタを監視し、重要な構成変更を展開し、クラスタの状態が分岐した場合は展開者の申告通りに戻す。例えば、ある特定の「ポッド」（後述）のインスタンスを3つ実行する必要があるとデプロイヤーが指定した場合、etcdはこの事実を保存します。デプロイメントコントローラは、（etcdの宣言と矛盾する）2つのインスタンスしか実行されていないことを発見すると[40]、そのポッドの追加インスタンスの作成をスケジュールします[36]。\nスケジューラは、リソースの利用可能性に基づいて、スケジュールされていないポッド（スケジューラが管理する基本的なエンティティ）をどのノードで実行するかを選択する拡張可能なコンポーネントである。スケジューラは、各ノードのリソース使用を追跡して、利用可能なリソースを超えるワークロードがスケジュールされないようにします。この目的のために、スケジューラはリソース要件、リソースの利用可能性、およびサービス品質、アフィニティ対アンチアフィニティの要件、データの局所性など、ユーザーが提供するその他の制約やポリシー指示を知っていなければなりません。スケジューラの役割は、リソースの「供給」とワークロードの「需要」を一致させることである[41]。\nコントローラは、実際のクラスタ状態を望ましい状態に導く調停ループであり、APIサーバと通信して管理するリソース（ポッドやサービスエンドポイントなど）を作成、更新、削除します[42][38]。コントローラの一種がレプリケーションコントローラで、クラスタ全体でポッドの指定数のコピーを実行してレプリケーションとスケーリングを扱います。また、基礎となるノードに障害が発生した場合に、代替ポッドの作成も行います。[42] Kubernetesのコアシステムの一部である他のコントローラには、すべてのマシン（またはマシンのサブセット）で正確に1つのポッドを実行するデーモンセットコントローラや、完了まで実行するポッドを（例えば、バッチジョブの一部として）実行するジョブコントローラがあります[43]。コントローラの定義の一部をなすラベルセレクタは、コントローラが管理するポッドの集合を指定します[44]。\nコントローラーマネージャーは、Kubernetesのコアとなるコントローラーのセットを管理するプロセスです。","output":"イーティーシー","category":"closed_qa"}
