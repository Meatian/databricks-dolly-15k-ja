{"index":"7438","instruction":"Scala FutureのonComplete関数とandThen関数の違いは何ですか？","input":"","output":"andThen`と `onComplete` はどちらも、コールバック関数によって未来の結果を観察することができます。しかし、`andThen`は連鎖させることができ、`onComplete`とは異なり、コールバック関数の適用順序を保証しています。さらに、`andThen`に与えられるコールバックは、結果のサブセット（例えば、`Success`のみ、または`Failure`のみ）を処理する部分関数である可能性があります。\n\nandThen`と`map`を使った次の例を考えてみましょう：\n\n```\ndef demoAndThen(fut: Future[Int])：Future[Int]＝{」とする。\n  fut.andThen { case Success(value) => println(s \"andThen1: $value\") }.\n    .andThen { case Success(value) => println(s \"andThen2: $value\") }.\n    .マップ { i =>\n      println(s \"マップ：$i\")\n      i\n    }\n}\n```\n\nfut`が正常に終了すると、\"andthen1: ...\"、\"andThen2: ...\"、\"map: ... \"の順で出力されます。\n\nonComplete`と`map`を使った類似の例を考えてみましょう：\n\n```\ndef demoOnComplete(fut: Future[Int])：Future[Int]＝{」とする。\n  fut.onComplete { t：Try[Int] => println(s \"onComplete1: $t\") }.\n  fut.onComplete { t：Try[Int] => println(s \"onComplete2: $t\") }.\n  fut.map { i =>\n    println(s \"マップ：$i\")\n    i\n  }\n}\n```\n\nこの場合、`fut`が正常に終了すると、\"onComplete1: ...\", \"onComplete2: ...\", \"map: ... \"が不特定の順序で出力されます。\n\nandThen`は連鎖しますが、コールバック関数が結果の `Future` の結果に影響を与えることは一般的にありません。しかし、コールバック関数が致命的なエラーを投げると、結果の未来は決して完成しないことに注意してください。","category":"open_qa"}
